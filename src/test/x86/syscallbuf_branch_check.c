/* -*- Mode: C; tab-width: 8; c-basic-offset: 2; indent-tabs-mode: nil; -*- */

#include "util.h"

static const uint8_t forward_branch_code[134] = {
  0xeb, 0x7f, /* jmp target */
  /* 125 nops */
  0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90,
  0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90,
  0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90,
  0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90,
  0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90,
  0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90,
  0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90,
  0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90,
  0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90,
  0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90,
  0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90,
  0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90,
  0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90,
  0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90,
  0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90,
  0x90, 0x90, 0x90, 0x90, 0x90,
  0x0f, 0x05, /* syscall */
  /* target: nop; nop; nop; ret */
  0x90, 0x90, 0x90, 0xc3,
};

static const uint8_t backward_branch_code[132] = {
  0xe3, 0x06, /* jecxz skip */
  0x0f, 0x05, /* syscall */
  /* target: nop; nop; nop; ret */
  0x90, 0x90, 0x90, 0xc3,
  /* skip: 122 nops */
  0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90,
  0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90,
  0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90,
  0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90,
  0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90,
  0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90,
  0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90,
  0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90,
  0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90,
  0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90,
  0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90,
  0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90,
  0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90,
  0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90,
  0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90,
  0x90, 0x90,
  /* jmp target */
  0xeb, 0x80,
};

static const uint8_t standalone_syscall[6] = {
  0x0f, 0x05, /* syscall */
  /* nop; nop; nop; ret */
  0x90, 0x90, 0x90, 0xc3,
};

static long do_call(uint8_t* page, uint8_t* code, int ecx) {
  long ret;
  mprotect(page, 1, PROT_READ | PROT_EXEC);
  __asm__ __volatile__("call *%3\n\t" : "=a"(ret) :
                       "a"(SYS_sched_yield), "c"(ecx), "d"(code));
  mprotect(page, 1, PROT_READ | PROT_WRITE);
  return ret;
}

int main(void) {
  size_t page_size = sysconf(_SC_PAGESIZE);
  uint8_t* p = mmap(NULL, page_size * 3, PROT_READ | PROT_WRITE,
                    MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);
  uint8_t* code;
  test_assert(p != MAP_FAILED);
  munmap(p, page_size);
  munmap(p + 2*page_size, page_size);

  p += page_size;

  /* Test that code is patched even when it starts at a page boundary */
  memcpy(p, standalone_syscall, sizeof(standalone_syscall));
  do_call(p, p, 0);
  test_assert(p[0] == 0xe9);

  /* Test that code is patched even when it ends at a page boundary */
  code = p + page_size - sizeof(standalone_syscall);
  memcpy(code, standalone_syscall, sizeof(standalone_syscall));
  do_call(p, code, 0);
  test_assert(code[0] == 0xe9);

  memcpy(p, forward_branch_code, sizeof(forward_branch_code));
  do_call(p, p, 0);
  /* Code should not have been patched, due to the inferering branch */
  test_assert(memcmp(p, forward_branch_code, sizeof(forward_branch_code)) == 0);

  memcpy(p, backward_branch_code, sizeof(backward_branch_code));
  do_call(p, p, 1);
  /* Code should not have been patched, due to the inferering branch */
  test_assert(memcmp(p, backward_branch_code, sizeof(backward_branch_code)) == 0);

  atomic_puts("EXIT-SUCCESS");
  return 0;
}
